<!DOCTYPE html>
<html>
<head>
<title> QA </title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="style_qa.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>

<ul class="menu">
	<li style="display: inline-block;"><a href="https://josephgravellier.github.io/sideline/" class="links_menu col-menu" width=10%>SideLine</a></li>	&nbsp;	&nbsp;	&nbsp;	&nbsp;
	<li style="display: inline-block;"><a href="qa.html" class="links_menu col-menu"><b>Q &amp; A</b></a></li>	&nbsp;	&nbsp;	&nbsp;	&nbsp;
	<li style="display: inline-block;"><a href="reproduce.html" class="links_menu col-menu">Reproduce</a></li>
</ul>

<hr>

	<div class = "logo_and_text col-logo-text">
  
  
 <div class="subtitle">
 <b>About SideLine Impact</b><br/><br/>
 </div>
    
    
<div class="text">
  
<li><b>SideLine is unprecedented.</b> This is the first time that intra power side-channel attacks are launched on complex SoCs with rich OS implemented. Especially it introduces internal CPU-vs-MCU side-channel attacks which clearly meet real-life scenarios on state-of-the-art SoCs.</li><br/>

<li><b>SideLine is not obvious</b>, it does not use a sensor. It leverages a performance mechanism whose security implication was not even questioned until now. It is the starting point of a novel area of research distracting hardware IPs from their primary use to collect information. </li><br/>

<li><b>SideLine is everywhere</b>. Every processor that uses external memory is potentially vulnerable. While our contribution focused on ARM devices, x86 and RISC-V exploits seem likely to arise in the near future.</li><br/>

<li><b>SideLine is not a magic bullet</b>. It doesn't pretend thwarting existing counter-measures against SCA. Rather it aims at warning the community that even remote systems, that by nature were not supposed to be the target of SCA, are now at risk.</li><br/>
</div>

 <div class="subtitle">
 <b>About Attack Privileges</b><br/><br/>
 </div>
 
<div class="list">
 <b>The attacker is root:</b>
He can use mmapping to access the delay line registers.<br/><br/>
<li>He may target an encryption trustlet running within a Trusted Execution Environment.</li><br/>
<li>He may target a crypto module or a security dedicated MCU e.g AP-to-MCU scenario in the paper. </li><br/><br/>

 <b>The attacker isn't root:</b>
no access to mmapping<br/><br/>

<li>He may take advantage of an existing kernel device that enables user-space processes to access the memory controller registers (e.g through DRAM test program disassembling) and then conduct the above attacks.</li><br/><br/>
 </div>
 
 
  <div class="subtitle">
 <b>Other Questions</b><br/>
 </div>
 
 <div class="text">
 
<b>About Setup Complexity:</b> All we need is a laptop (acquisition and CPA), a micro-USB cable and the development board. (an AC adapter was used for the second target).<br/><br/>

<b>Was the temperature controlled?</b>  No, during the Covid19 period, we had to conduct the experiments outside the lab with no access to any thermal chamber. However, the temperature noise was taken into account to improve the attack results. We attenuated its effect by applying post-treatment high-pass filtering on the collected SCA traces.<br/><br/>

<b>How did you run OpenSSL in a bare metal setting?</b> The workaround we found was to only download AES related sources. We then used the AES_ecb_encrypt function to conduct the experiments.<br/><br/>

<b>How can one actually read out the command register?</b> By simply reading at the register physical address: DLL_value = *(volatile u32 *) DLL_Addr<br/><br/>

<b>Do you assume nothing else is running on the system?</b> No, there is the whole Linux rich OS running in background with kernel processes, interrupts, etc.<br/><br/>

<b>Can you generate a baseline while some other, unknown code is running?</b> Yes, we are working on multi-core processors that handle simultaneous thread execution.<br/><br/>

<b>How do you know when an encryption is being performed?</b> In local SCA, the attacker needs to trigger an encryption. We believe that the exact same is possible in an internal SCA scenario. Hence, the application processor (attacker) may trigger hardware acceleration (victim) by asking for a signature, an encryption, etc.<br/><br/>

<b>About DLL update frequency:</b>  By definition, the DLL update has to be fast to ensure proper DRAM operation. That's why we obtain decent sampling frequency (16MHz) compared to what we could have done with low cost ADCs (&lt;1MHz).<br/><br/>

<b>About DLL data type:</b> The datatype is defined as delay value. The command range is (0:64) for coarse-delay and (0:3) for fine-delay. The delay value can be represented as the phase shift applied to the signal. Unfortunately, SoC providers do not give precise information to convert the delay value into phase shift.<br/>

	</div>

	<div class="text_bottom">
		&copy; Joseph Gravellier 2020, All Rights Reserved
	</div>
  </div>
	<ul class="menu">
	<li style="display: inline-block;"><a href="https://josephgravellier.github.io/sideline/" class="links_menu col-menu" width=10%><b>SideLine</b></a></li>	&nbsp;	&nbsp;	&nbsp;	&nbsp;
	<li style="display: inline-block;"><a href="/qa/" class="links_menu col-menu">Q &amp; A</a></li>	&nbsp;	&nbsp;	&nbsp;	&nbsp;
	<li style="display: inline-block;"><a href="/reproduce/" class="links_menu col-menu">Reproduce</a></li>
</ul>

</body>
</html>
